<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta content="HTML Tidy for Linux (vers 25 March 2009), see www.w3.org" name="generator" />
  <link href="prettify/prettify.css" rel="stylesheet" type="text/css" />
  <link href="style.css" rel="stylesheet" type="text/css" />
  <script src="prettify/prettify.js" type="text/javascript">
</script>

  <title>Testify software testing library</title>
</head>

<body onload="prettyPrint()">
  <div id="page">
    <div id="main">
      <div>
        <img src="http://upload.wikimedia.org/wikipedia/en/thumb/b/ba/Testify.jpg/220px-Testify.jpg" />

        <h1>Testify</h1>
      </div>

      <p>Testify is a software testing library that you don't need to learn, so you can write tests sooner. You don't need to learn Testify because a test can be *any* script - you don't even need to import Testify!</p>
      <pre>
<code class="prettyprint">from mything import awesome

widget = awesome.Widget('This is only a test')

print 'Cool, it works!' if 'What I expected' == widget.throb() else 'Fail, bummer'</code>
</pre>

      <p>Other software testing tools impose a bunch of structure on tests, which is important in the long run for maintaining large suites of tests. But up front I never understood,</p>

      <ol>
        <li>What all the structure means</li>

        <li>How my tests fit this <a href="http://en.wikipedia.org/wiki/Procrustes#Contemporary_usage">Procrustean bed</a> - I spent more time thinking about what tests the tool promotes, instead of what tests actually build confidence in my code</li>
      </ol>

      <p>Time learning and adopting some tool is totally justified if a project survives to maturity, but investing time up front could be a big waste if not. Focussing on tools up front is just one more distraction from focussing on releasing only the absolute necessary features of a project</p>

      <p>First workaround? Write tests in prose, as I spot needs for them, and automate them with tools later. Certainly better than no tests at all - but not much better because they must be run by hand and so rarely do get run. And they *never* get around to being implemented with tools</p>

      <p>Solution? Abandon tools - write automated tests however makes sense</p>

      <p>Testify's target audience is anyone who's more productive hacking their own tools than finding and adopting existing tools. Hence no one will use Testify because it's target audience is busy hacking their own tools. Testify is Yet Another Software Testing Tool - it probably already exists but I didn't search hard</p>

      <p>Testify is inspired by <a href="http://docs.jquery.com/Qunit">QUnit</a> and <a href="http://en.wikipedia.org/wiki/Lime_%28software%29">lime</a>, wich also impose minimal structure on tests</p>

      <p>Testify provides some utilities,</p>

      <ul>
        <li><code class="prettyprint">ok()</code> - something that was expected actually happened</li>

        <li><code class="prettyprint">ok(condition, actual)</code> - fail if condition is false and print the actual value</li>

        <li><code class="prettyprint">equal(actual, expect)</code> - fail if actual value not equal to expected value and print both values</li>

        <li><code class="prettyprint">expect(count)</code> - expect so many assertions and fail if fewer or more are actually executed</li>
      </ul>

      <h3>Example</h3>
      <pre>
<code class="prettyprint">from mything import awesome
from testify import *

expect(1)

widget = awesome.Widget('This is only a test')

equal(widget.throb(), 'What I expected')</code>
</pre>

      <p>Testify can also help add some structure when you're ready for it,</p>
      <pre>
<code class="prettyprint">from mything import awesome
from testify import *

@test
def throbInSomeContext():
  expect(1)

  widget = awesome.Widget('Some interesting context')

  equal(widget.throb(), 'Expected in this context')

@test
def blowUp():
  expect(1)

  try:
    awesome.Widget('Illegal argument!')

  except awesome.Error:
    ok()</code>
</pre>
    </div>
  </div>
</body>
</html>
